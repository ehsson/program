#include <stdio.h>

#define LINE_MAX	1501
#define NODE_MAX	2001

enum {
	DOWN = 0,
	SIDE
};

typedef struct Node {
	int side_line[2];
} node_s;

node_s node[LINE_MAX][NODE_MAX];
int node_cnt[LINE_MAX];

int broken_ladder_sum = 0;
int broken_ladder_min = NODE_MAX;

void dfs(int destination, bool from, int now, int node_pos_now, int broken_cnt)
{
	// 끝나는 조건
	if (broken_ladder_min == 0 || broken_cnt > broken_ladder_min) {
		return;
	}

	// line 끝에 도착했다면
	if (node_pos_now == node_cnt[ now ]) {
		// 도착한 곳이 목적지라면
		if (now == destination && broken_cnt < broken_ladder_min) {
			broken_ladder_min = broken_cnt;
		}
		return;
	}

	//위쪽 node 에서 현재 node로 왔을 때,
	if (from == DOWN) {
		int next_line = node[now][node_pos_now].side_line[0];
		int next_pos = node[now][node_pos_now].side_line[1];

		dfs(destination, SIDE, next_line, next_pos, broken_cnt);

		broken_cnt++;
	}

	// 위쪽 node 에서 현재 node에 와서, 다시 아래쪽으로 이동할 경우 broken_cnt 증가
	// 만약 SIDE 로 왔을 경우에는 아래쪽으로 내려가지만 broken_cnt 를 증가시키지 않음
	dfs(destination, DOWN, now, node_pos_now + 1, broken_cnt);

	// 변경된 dfs 조건 원복
	// 원복할 데이터가 없음
}

int main(void)
{
	FILE *pf;
	freopen_s(&pf, "input.txt", "r", stdin);

	int T;
	int N, K, M;
	int line_1, line_2;
	int start, destination;

	scanf_s("%d", &T);

	for (int t = 1; t <= T; t++) {
		scanf_s("%d %d %d", &N, &K, &M);

		// 모든 node 초기화
		for (int li = 1; li <= N; li++) {
			node_cnt[li] = 0;
		}

		//사다리 정보(양쪽 road 의 교차로 지점)를 양쪽 road에 각각 저장
		for (int no = 1; no <= K; no++) {
			scanf_s("%d %d", &line_1, &line_2);

			node_cnt[line_1]++;
			node_cnt[line_2]++;

			node[ line_1 ][ node_cnt[line_1] ].side_line[0] = line_2;
			node[ line_1 ][ node_cnt[line_1] ].side_line[1] = node_cnt[line_2];

			node[ line_2 ][ node_cnt[line_2] ].side_line[0] = line_1;
			node[ line_2 ][ node_cnt[line_2] ].side_line[1] = node_cnt[line_1];
		}
		
		//사다리가 끝나는(end) 것을 표시
		for (int li = 1; li <= N; li++) {
			node_cnt[li]++;

			node[ li ][ node_cnt[li] ].side_line[0] = li;
			node[ li ][ node_cnt[li] ].side_line[1] = node_cnt[li];
		}

		for (int m = 1; m <= M; m++) {
			scanf_s("%d %d", &start, &destination);

			dfs(destination, DOWN, start, 1, 0);

			if (broken_ladder_min == NODE_MAX) {
				broken_ladder_sum--;
			} else {
				broken_ladder_sum += broken_ladder_min;
			}

			broken_ladder_min = NODE_MAX;
		}

		printf("Case #%d\n%d\n", t, broken_ladder_sum);

		broken_ladder_sum = 0;
	}

	return 0;
}
